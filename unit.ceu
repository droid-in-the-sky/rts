class Unit with
    var  _SDL_Rect      rect;           // position (x,y) and dimension (w,h).
    var _SDL_Texture*   tex = null;
    var _Mix_Chunk*     snd = null;

    var bool            selected? = 0;  // to receive commands from player
    var int             life   = 0;     // dies when <= 0
    var int             damage = 0;     // inflicts at most this damage
    var int             speed  = 0;     // moving speed (px/sec)

    event Unit*         go_collide;     // collided with "Unit"
    event int           go_hit;         // hitted with "int" damage
    event _SDL_Point*   go_point;       // move to "_SDL_Point" (null stop)
do
    _assert(this.tex    != null);
    _assert(this.snd    != null);
    _assert(this.life   != 0);
    _assert(this.damage != 0);
    _assert(this.speed  != 0);

    // standing frame
    var _SDL_Rect clip;
        clip.x = 0;
        clip.y = 0;
        clip.w = 32;
        clip.h = 48;

    par/or do
        // hits the colliding opponent
        // TODO: only one (possibly always the same)
        loop do
            var Unit* u = await this.go_collide;
            var _SDL_Point pt;
                pt.x = u:rect.x + u:rect.w/2;
                pt.y = u:rect.x + u:rect.h/2;
            _Mix_PlayChannel(-1, this.snd, 0);
            emit u:go_hit => this.damage;

            // "reaction time": avoids continuous hits
            await (1000-this.speed)ms;
                    // TODO: 1000
        end
    with
        var int v;
        every v=this.go_hit do
            this.life = life - v;
            if life <= 0 then
                break;
            end
        end
        await 100ms;    // last breath
    with
        // move to "pt_goto" on "this.go_point"

        var bool       pt_goto? = false;
        var _SDL_Point pt_goto;     // set on "go_point"
        var float      pt_goto_vx;
        var float      pt_goto_vy;

        // use float on calculations (write back to "rect" on each "DT" cycle)
        var float sx = this.rect.x;
        var float sy = this.rect.y;

        // fallback position on collisions
        var int pt_goto_old_x = this.rect.x;
        var int pt_goto_old_y = this.rect.y;

        loop do
            finalize with
                clip.x = 0;     // always terminate on standing position
            end
            par/or do
                var _SDL_Point* to = await go_point;
                pt_goto? = (to != null);
                if to != null then
                    pt_goto := *to;
                end
                            // point is plain type
            with
                every this.go_collide do
                    this.rect.x = pt_goto_old_x;
                    this.rect.y = pt_goto_old_y;
                    sx = pt_goto_old_x;
                    sy = pt_goto_old_y;
                end
            with
                if not pt_goto? then
                    await FOREVER;
                end

                // calculate speed ratio "vx" vs "vy"
                var float dx = _abs(this.rect.x - pt_goto.x);
                var float dy = _abs(this.rect.y - pt_goto.y);
                if dx == 0 then
                    pt_goto_vx = 0;
                    pt_goto_vy = this.speed;
                else/if dy == 0 then
                    pt_goto_vx = this.speed;
                    pt_goto_vy = 0;
                else
                    pt_goto_vx = this.speed / _sqrt(1 + _pow(dy/dx,2));
                    pt_goto_vy = pt_goto_vx * (dy/dx);
                end

                par do
                    var int dt;
                    every dt = SDL_DT do
                        pt_goto_old_x = this.rect.x;    // save as old position
                        pt_goto_old_y = this.rect.y;    // to avoid collision

                        var float vx = pt_goto_vx;
                        if sx > pt_goto.x then
                            vx = -vx;
                        end
                        sx = sx + vx*dt/1000;

                        var float vy = pt_goto_vy;
                        if sy > pt_goto.y then
                            vy = -vy;
                        end
                        sy = sy + vy*dt/1000;

                        this.rect.x = sx;
                        this.rect.y = sy;

                        if  (vx>0 and this.rect.x>=pt_goto.x or
                             vx<0 and this.rect.x<=pt_goto.x)
                        and (vy>0 and this.rect.y>=pt_goto.y or
                             vy<0 and this.rect.y<=pt_goto.y)
                        then
                            this.rect.x = (int)pt_goto.x;    // round to destination
                            this.rect.y = (int)pt_goto.y;    //   ""
                            emit go_point => null;      // destination reached
                        end
                    end
                with
                    // animate sprite frames
                    loop do
                        loop i, 4 do
                            clip.x = clip.w*i;
                            await 200ms;      // TODO: consider speed
                        end
                    end
                end
            end
        end
    with
        every SDL_REDRAW do
            var int w2 = rect.w / 2;
            var int h2 = rect.h / 2;
            if this.selected? then
                _filledCircleRGBA(_REN, rect.x+w2,rect.y+h2, h2,
                                        0x88,0x88,0x88,0x88);
            end
/*
            if pt_goto? then
                _SDL_RenderDrawLine(_REN, rect.x+w2, rect.y+h2,
                                          pt_goto.x+w2, pt_goto.y+h2);
            end
*/
            _SDL_RenderCopy(_REN, this.tex, &clip, &this.rect);
        end
    end
end
