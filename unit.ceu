class Melee with
    interface Visible;
        var int id    = 0;
        var int speed = 0;

    var _SDL_Point to;
do
    _assert(this.id     != 0);
    _assert(this.speed  != 0);

    var Visible* me = &this;
    var MoveVisible move with
        this.vis = me;
        this.to  = to;
    end;

    var bool hit? = false;
    par/or do
        var Visible* vis = await this.go_collide;
        hit? = (vis:id != this.id);
        if hit? then
            emit vis:go_hit => 10;    // TODO: damage
        end
    with
        await move.ok;      // missed
    end

    if hit? then
        _Mix_PlayChannel(-1, _SND_SWORD, 0);
        par/or do
            await 100ms;
        with
            every SDL_REDRAW do
                _filledCircleRGBA(_REN, rect.x,rect.y, rect.w/2,
                                        0xCC,0x00,0x00,0xFF);
            end
        end
    end
end

class Unit with
    interface Visible;
        var int id    = 0;
        var int speed = 0;

    var _SDL_Texture*   tex = null;

    var bool            selected? = 0;  // to receive commands from player
    event _SDL_Point*   go_point;       // move to "_SDL_Point" (null stop)
do
    _assert(this.id     != 0);
    _assert(this.speed  != 0);
    _assert(this.tex    != null);
    _assert(this.life   != 0);

    // standing frame
    var _SDL_Rect clip;
        clip.x = 0;
        clip.y = 0;
        clip.w = 32;
        clip.h = 48;

    pool Melee[1] melees;

    par/or do
        // hits the colliding opponent
        // TODO: only one (possibly always the same)
        var Visible* vis;
// TODO: iterate myself
        every vis in this.go_collide do
            if vis:id == this.id then
                continue;
            end

            spawn Melee in melees with
                this.id    = id;
                this.speed = speed*2;
                this.to    := _SDL_Rect2Point(&vis:rect);
                           // point is plain type

                this.rect.x = this.to.x - 2;
                this.rect.y = this.to.y - 2;
                this.rect.w = 5;
                this.rect.h = 5;
            end;
        end
    with
        var int v;
        every v in this.go_hit do
            this.life = life - v;
            if life <= 0 then
                break;
            end
        end
        await 100ms;    // last breath
    with
        var bool       go? = false;
        var _SDL_Point to;
        loop do
            finalize with
                clip.x = 0;     // always terminate on standing position
            end
            par/or do
                var _SDL_Point* ptr = await go_point;
                go? = (ptr != null);
                if ptr != null then
                    to := *ptr;
                       // point is plain type
                end
            with
                if not go? then
                    await FOREVER;
                end
                go? = false;    // not again

                // move "this" to "*to"
                var Unit* me = &this;
                var MoveVisible move with
                    this.vis = me;
                    this.to  = to;  // TODO: := ??
                end;
                // animate sprite frames while moving
                par/or do
                    await move.ok;
                with
                    loop do
                        loop i in 4 do
                            clip.x = clip.w*i;
                            await (10000/this.speed)ms;
                        end
                    end
                end
            end
        end
    with
        every SDL_REDRAW do
            var int w2 = rect.w / 2;
            var int h2 = rect.h / 2;
            if this.selected? then
                _filledCircleRGBA(_REN, rect.x+w2,rect.y+h2, h2,
                                        0x88,0x88,0x88,0x88);
            end
/*
            if pt_goto? then
                _SDL_RenderDrawLine(_REN, rect.x+w2, rect.y+h2,
                                          pt_goto.x+w2, pt_goto.y+h2);
            end
*/
            _SDL_RenderCopy(_REN, this.tex, &clip, &this.rect);
        end
    end
end
